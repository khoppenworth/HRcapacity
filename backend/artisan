#!/usr/bin/env php
<?php

use Illuminate\Contracts\Console\Kernel;

define('LARAVEL_START', microtime(true));

$autoloadPath = __DIR__ . '/vendor/autoload.php';

if (! file_exists($autoloadPath)) {
    exit(handleWithoutLaravel($argv));
}

require $autoloadPath;

$bootstrapPath = __DIR__ . '/bootstrap/app.php';

if (! file_exists($bootstrapPath)) {
    exit(handleWithoutLaravel($argv));
}

$app = require $bootstrapPath;

$kernel = $app->make(Kernel::class);

$status = $kernel->handle(
    $input = new Symfony\Component\Console\Input\ArgvInput(),
    new Symfony\Component\Console\Output\ConsoleOutput()
);

$kernel->terminate($input, $status);

exit($status);

function handleWithoutLaravel(array $argv): int
{
    array_shift($argv); // Remove script name.

    if (empty($argv)) {
        fwrite(STDERR, "Composer dependencies are not installed.\n");

        return 1;
    }

    $command = array_shift($argv);

    if ($command === 'key:generate') {
        return generateApplicationKey($argv);
    }

    if ($command === 'key' && ($argv[0] ?? null) === 'generate') {
        array_shift($argv);

        return generateApplicationKey($argv);
    }

    if ($command === 'migrate') {
        return runOfflineMigrations($argv);
    }

    if ($command === 'db:seed' || ($command === 'db' && ($argv[0] ?? null) === 'seed')) {
        if ($command === 'db') {
            array_shift($argv);
        }

        return runOfflineSeeding($argv);
    }

    if ($command === 'config:cache' || ($command === 'config' && ($argv[0] ?? null) === 'cache')) {
        if ($command === 'config') {
            array_shift($argv);
        }

        return runOfflineOptimization('config', $argv);
    }

    if ($command === 'route:cache' || ($command === 'route' && ($argv[0] ?? null) === 'cache')) {
        if ($command === 'route') {
            array_shift($argv);
        }

        return runOfflineOptimization('route', $argv);
    }

    fwrite(STDERR, "Composer dependencies are not installed. Unsupported command.\n");

    return 1;
}

function generateApplicationKey(array $options): int
{
    $showOnly = in_array('--show', $options, true);

    try {
        $key = 'base64:' . base64_encode(random_bytes(32));
    } catch (Exception $exception) {
        fwrite(STDERR, 'Unable to generate application key: ' . $exception->getMessage() . "\n");

        return 1;
    }

    if ($showOnly) {
        fwrite(STDOUT, $key . "\n");

        return 0;
    }

    $envPath = __DIR__ . '/.env';

    if (! file_exists($envPath)) {
        $examplePath = __DIR__ . '/.env.example';

        if (file_exists($examplePath)) {
            if (! copy($examplePath, $envPath)) {
                fwrite(STDERR, "Failed to create .env file from .env.example.\n");

                return 1;
            }
        } else {
            if (file_put_contents($envPath, '') === false) {
                fwrite(STDERR, "Failed to create .env file.\n");

                return 1;
            }
        }
    }

    $envContents = file_get_contents($envPath);

    if ($envContents === false) {
        fwrite(STDERR, 'Unable to read .env file.' . "\n");

        return 1;
    }

    $pattern = '/^APP_KEY=.*$/m';

    if (preg_match($pattern, $envContents) === 1) {
        $replaced = preg_replace($pattern, 'APP_KEY=' . $key, $envContents);

        if ($replaced === null) {
            fwrite(STDERR, 'Failed to update the application key in .env.' . "\n");

            return 1;
        }

        $envContents = $replaced;
    } else {
        if ($envContents !== '' && substr($envContents, -1) !== "\n") {
            $envContents .= "\n";
        }

        $envContents .= 'APP_KEY=' . $key . "\n";
    }

    if (file_put_contents($envPath, $envContents) === false) {
        fwrite(STDERR, 'Unable to write application key to .env file.' . "\n");

        return 1;
    }

    fwrite(STDOUT, "Application key set successfully.\n");

    return 0;
}

function runOfflineMigrations(array $options): int
{
    $unsupported = array_filter($options, static function ($option): bool {
        if ($option === '--') {
            return false;
        }

        return ! str_starts_with($option, '--');
    });

    if (! empty($unsupported)) {
        fwrite(STDERR, 'Composer dependencies are not installed. Unsupported migrate arguments: ' . implode(', ', $unsupported) . "\n");

        return 1;
    }

    fwrite(STDOUT, "Offline database is already migrated. No actions were required.\n");

    return 0;
}

function runOfflineSeeding(array $options): int
{
    [$unsupported, $flags] = partitionUnsupportedOptions($options);

    if (! empty($unsupported)) {
        fwrite(STDERR, 'Composer dependencies are not installed. Unsupported db:seed arguments: ' . implode(', ', $unsupported) . "\n");

        return 1;
    }

    $message = 'Offline database seeding is not required. No actions were performed.';

    if (in_array('--force', $flags, true)) {
        $message .= ' (Force flag ignored.)';
    }

    fwrite(STDOUT, $message . "\n");

    return 0;
}

function runOfflineOptimization(string $type, array $options): int
{
    [$unsupported] = partitionUnsupportedOptions($options);

    if (! empty($unsupported)) {
        fwrite(STDERR, sprintf(
            'Composer dependencies are not installed. Unsupported %s:cache arguments: %s' . "\n",
            $type,
            implode(', ', $unsupported)
        ));

        return 1;
    }

    $target = $type === 'config' ? 'Configuration' : 'Route definitions';
    fwrite(STDOUT, sprintf('%s cache is already optimized for the offline backend.%s', $target, "\n"));

    return 0;
}

/**
 * @return array{0: array<int, string>, 1: array<int, string>}
 */
function partitionUnsupportedOptions(array $options): array
{
    $unsupported = [];
    $flags = [];

    foreach ($options as $option) {
        if ($option === '--') {
            continue;
        }

        if (str_starts_with((string) $option, '--')) {
            $flags[] = $option;
            continue;
        }

        $unsupported[] = $option;
    }

    return [$unsupported, $flags];
}
